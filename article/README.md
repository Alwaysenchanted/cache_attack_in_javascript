# \[译\] 沙箱中的间谍 - 可行的 JavaScript 高速缓存区攻击
----------------------------------

## 关于

> 龙天，全栈工程师，现居北京。偶遇[原文](http://arxiv.org/pdf/1502.07373v2.pdf)，脑洞大开，知识点涉及计算机组成原理，虚拟化，性能分析
> ，JavaScript，HTML5规范等，有很强的实效性（2015年），再加上多次提及[老东家](https://cn.linkedin.com/in/longtian)的产品，因此译者
> 虽然是安全领域的小白，还是尝试精读并且斗胆翻译，不足之处欢迎大家批评指正。如果您有任何意见和建议请猛戳
> [issues](https://github.com/wyvernnot/cache_attack_in_javascript/issues)

## 术语表
- cache memory 高速缓存
- cycle count 周期数
- Cache line 缓存线
- cache miss 缓存未命中
- Cache set 缓存块（组）
- canonical 正规
- covert channel 隐藏通道
- eviction 淘汰
- eviction buffer
- eviction set 移除集
- flow tracking
- last-level cache
- native language 
- micro-architectural 微架构
- page frame 页框
- PRIME + PROBE 填充和探测
- privilege ring 特权环
- protection rings 保护机制
- side-channel 边信道

## 相关文章

- [freeshell修复边信道攻击漏洞](http://www.2cto.com/Article/201409/332354.html)
- http://baike.baidu.com/link?url=jQGLb4ZNHV9ReIvGyRJppN94pp-ztWK-qcN0vsNzJTeKy3Htl6YpDgguwRtP2OGHpwKoX0U0vpTvqD-tuYXWa_
- http://www.docin.com/p-692268752.html
- [10] https://www.usenix.org/conference/woot14/workshop-program/presentation/ho
- http://danluu.com/2choices-eviction/
- http://novoland.github.io/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html
- http://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2?cmp

# 以下是正文
------------------------

## 作者和单位

- Yossef Oren <yos AT cs.columbia.edu>
- Vasileios P. Kemerlis <vpk AT cs.columbia.edu>
- Simha Sethumadhavan <simha AT cs.columbia.edu>
- Angelos D. Keromytis <angelos AT cs.columbia.edu>

哥伦比亚大学计算机系

## 摘要

我们将展示首个完全运行在浏览器里的针对微架构的边信道攻击手段。与这个领域里的其它研究成果不同，这一手段不需要攻击者在受害者的电脑上安装任何的
应用程序来展开攻击，受害者只需要打开一个被攻击者控制的不可信的网页。这种攻击模型可伸缩性高，易行，贴近当今的网络环境，尤其是因为绝大多数连接到 Internet
的桌面浏览器都无法防御。这种攻击手段是 Yarom 等人在 文[23] 提出的 last-level cache 攻击的扩展，可以让对手远程获得属于其它进程、用户甚至是虚拟机的信息，
只要它们和受害者的浏览器运行在运行在同一台物理主机上。我们将描述了这种攻击背后的基本原理，用一种高带宽的隐藏通道验证它的性能，最后
用它构建了一个全系统鼠标和网络活动的记录器。抵抗这种攻击是可能的，但是所需反制措施将会对浏览器和电脑的正常使用产生不实际的代价。

## 1 引言

边信道分析是里一种非常强大的密码分析攻击。攻击者通过分析安全设备内部在进行安全运算时所产生的的物理信号（功率，辐射，热量等）来取得秘密信息[15]。
据说在二战中便有情报部门在使用，并由 Kocher 等人在1996年首次在学术情境下讨论[14]。边信道分析被证实可以用来侵入无数的现实世界中的系统，从汽车报警器
到高安全性的密码协处理器[8][18]。缓存区攻击（Cache Attack）是和个人电脑相关的一种边信道攻击，因为其被不同的进程或用户使用而导致秘密信息的泄露[17][11]。

虽然边信道攻击的能力不容置疑，但是要应用到实际的系统上是相对受限的。影响边信道攻击可行性的一个主要因素是对不确定的**攻击模型**的假设：除了基于网络的
时序攻击，大部分的边信道攻击都要求攻击者非常接近受害者。缓存攻击一般会假设攻击者能够在受害者的机器上执行任意的二进制的代码。虽然这个假设
适用于像 Amazon 云计算平台这样的 IaaS 或者 PaaS 环境，但是对于其它环境就不那么相关了。

在这篇报告里，我们用一种约束更少、更可行的攻击者模型挑战了这一限制性的安全假设。在我们的攻击模型里，受害者只需要**访问一个网页**，这个网页
由攻击者所拥有。我们会展示即使在这么简单的攻击者模型里，攻击者依然能够在可行的时间范围里，从被攻击的系统中提取出有意义的信息。为了和这样的
计算设定保持一致，我们把注意力集中在了**跟踪用户行为**而不是获取密匙上。报告中的攻击方式因此是高度可行的：对于攻击者的假设和限定是
实际的；运行的时间是实际的；给攻击者带来的好处也是实际的。据我们了解，这是首个可以轻松扩展至上百万个目标的边信道攻击方式。

我们假设攻击中受害者使用的个人电脑配备有较新型号的的 Intel CPU ，并进一步假设用户用支持 HTML5 的浏览器访问网页。这覆盖了绝大部分连接到 Internet 的
个人电脑,见 章节5.1 。用户被强迫访问一个页面，这个页面上有一个由攻击者控制的元素比如广告。攻击代码自己会执行基于 JavaScript 的
缓存攻击，见 章节2，持续地访问被攻击系统的 last-level cache (LLC) 。因为所有的 CPU 内核，用户，进程，保护机制等共享这同一个缓存，所以
可以为攻击者提供被攻击的用户和系统的详细信息。
 
### 1.1 现代 Intel CPU 的内存架构
 
现代的计算机系统通常会采用一个高速的中央处理器（CPU）和一个容量大但是速度较慢的随机存取器（RAM）。为了克服这两个模块的性能鸿沟，现代的计算机系统会采用
高速缓存 - 一种容量小但是速度更快的内存结构，里面保存了 RAM 中最近被 CPU 访问过的子集。高速缓存通常会采用 **分层** 设计，即在 CPU 和 RAM 
之间 **分层** 放置一些列逐渐变大和变慢的内存结构。图1 取自[22]，展示了 Intel Ivy Bridge 的缓存结构，包括：较小的 **level 1(L1) cache**，大一些的
**level 2 (L2) cache** ，最下方是最大的 **level 3 (L3) cache** 并和 RAM 相连。Intel 目前代号为 Haswell 的新一代 CPU 采用了另一种嵌入式的 
DRAM(eDRAM) 设计，所以不在本文讨论范围内。如果 CPU 需要访问的数据当前不在缓存里，会触发一个 **未命中** ，当前缓存里的一项必须被 **淘汰**
来给新元素腾出空间。

![图1](../assets/figure1.png)
  
Intel 的缓存微架构是 **嵌套的** - 所有一级缓存里的数据必须同时存在二级和三级缓存里。反之，如果某个元素在三级缓存里被淘汰，那它也会立刻被
从二级和一级缓存里移走。需要注意的是 AMD 缓存微架构的设计是非嵌套的，所以本文描述的方法并不能立刻应用到该平台上。
  
本文重点关注三级缓存，通常也被称为 last-level cache (LLC)。由于 LLC 较大，CPU 访问内存的时候如果把整个 LLC 的内容都搜索一遍效率会很低。
为了避免这个问题，LLC 通常被分成不同的 **缓存组**，每一组都对应者内存空间的一个固定的子集。每个组包含若干缓存线。例如，Intel Haswell 系列中的 
Core i7-3720QM 处理器拥有 8192 = 2^13 个组，每个组有 12 条 64 = 2^6 字节的缓存线，共同组成 8192 x 12 x 64 = 6 MB 的高速缓存。
CPU 如果要检查一个给定的物理地址是否在三级缓存里，会先计算出组，然后只检查组内的缓存线。结果就是，某个物理地址的缓存未命中，会导致同一个组的
为数不多的缓存线中的一条被淘汰，这个事实会被我们的攻击反复运用。由64比特长度的物理地址到13比特长度的组索引的映射方法已经被 Hund 等人在2013年
同过逆向工程得出来[12]。在表示物理地址的64个比特位里，5到0被忽略，16到6被直接用来作为组索引的低11位，63到17散列后得到组索引的高2位。
LLC 被所有的内核、线程、进程、用户，乃至运行在同一块 CPU 芯片上的虚拟机所共享，而不论特权环或其它类似的保护措施。

现代的个人电脑采用了一种 **虚拟内存机制**，在这种机制里，用户进程一般没法直接得到或访问系统的物理内存。取而代之的是，进程会被分配不同的虚拟内存**页**。
如果某个虚拟内存页被当前执行的进程访问，操作系统会在物理内存里动态地分配一个**页框**。CPU 的内存管理单元（MMU）负责把不同进程对虚拟内存地址的访问
映射到物理内存。Intel 处理器的页和页框大小一般是4KB，并且页和页框的是按照**页对齐**的 - 每页的开始地址是页大小的倍数。这意味着，任何虚拟地址
的低12位和对应的虚拟地址是一一对应的，这一事实也在我们的攻击中用到。

### 1.2 缓存攻击

缓存攻击是针对微架构的攻击手段中一个典型的代表， Aciamez 在他的出色的调查中将这类攻击定义为利用“信任架构边界下方的处理器底层结构”从不同的安全系统中
获取秘密信息。缓存攻击基于这样的事实：尽管在上层有诸多像沙箱、虚拟内存、特权环，宿主这样的保障机制，安全和不安全进程通过缓存的公用可以互相影响。攻击者构造一个
“间谍”进程后可以通过缓存的公用来测量和干扰其它安全进程的内部状态。Hu 在1992年的首次发现[11],在随后的一些研究成果里显示了边信道攻击可被用来获取
AES密匙[17][4],RSA密匙[19]，甚至可以允许一台虚拟机侵入宿主上的其它机器。

我们的攻击建立在 **填充+探测** 模型的基础上，这个方法由 Osvik 在[17]中首次描述，不过是针对一级缓存的。之后由 Yarom 等人在[23]中扩展到启用了
较大内存页系统的 LLC。我们把这个方法扩展了一下支持更加常见的 4K 的页大小。总的来说，缓存 **填+充探测** 有四个步骤。第一步，攻击者建立一个
或多个 **移除集**。移除集是内存中的一系列地址，这些地址被访问的时候会占据受害者进程使用的一条缓存线。第二步，攻击者通过访问移除集**填充**整个组。
这会强制受害者的代码或指令被从组中淘汰，并使组进入一个已知的状态。第三步，攻击者触发或只是等待受害者执行和可能使用组。最后，攻击者通过再次访问移除集
来**探测**组。如果访问的延迟比较低，意味着攻击者的指令或数据还在缓存里。反之，较高的访问延迟意味着受害者的代码用到了组，因此攻击者可以了解受害者的内部状态。
实际的时间测量是用非特权的汇编指令`RDTSC`进行的，这个指令可以得到处理器非常准确的周期数。再次遍历链表还有第二个目的，那就是强制组进入
受攻击者控制的状态，为下一轮的测量做好准备。

### 1.3 Web 运行环境

JavaScript 是一种拥有动态类型，基于对象的运行时求值的脚本语言，它支撑着现代万维网的客户端。JavaScript 代码以源码的形式传到浏览器端，由浏览器 *即时编译(JIT)*
的机制来编译和优化。不同浏览器厂商之间的激烈竞争使不断改进 JavaScript 性能备受关注。结果就是，在某些场景下，JavaScript 执行的效率已经
可以和机器码相媲美。

JavaScript 语言的核心功能是由 ECMA 产业协会在 ECMA-262 标准中定义的。语言标准由万维网协会（W3C）定义的一系 API 所补充，因此适合开发 Web 内容。
JavaScript API 的集合是不断演进的，浏览器厂商依照自己的开发计划不断增加新的 API 支持。我们的工作中用到两个具体的API:
第一个是类型数组的定义[9](https://www.khronos.org/registry/typedarray/specs/latest/)，通过它可以高效地访问非结构化的二进制数组。
第二个是高精度的时间 API[16](http://www.w3.org/TR/hr-time/)，让应用程序可以进行毫秒以下时间的测量。
如 章节5.1 所示，大部分当今主流的浏览器都同时支持这两个API。

JavaScript 代码运行在高度**沙箱化**的环境里 - 用 JavaScript 交付的代码对系统的访问非常受限。例如，JavaScript 代码如果没有用户的允许不能打开读取文件。
JavaScript 代码不能执行机器语言或者加载本地的代码库。
最值得注意的是，JavaScript 代码**没有指针的概念**，所以你连一个 JavaScript 变量虚拟地址都没法知道。
 
### 1.4 我们的工作

我们的目的是构造一个可以通过 Web 部署的 LLC 攻击。这个过程是充满挑战的，因为 JavaScript 代码没法加载共享库或者执行本机语言的程序，
并且由于无法直接调用专用的汇编指令而被迫调用脚本语言的函数进行时间的测量。尽管有这些挑战，我们还是成功地把缓存攻击扩展到了基于Web环境：

- 我们展示了一种用来在 LLC 上的建立 **非典型移除集** 特别方法。与[23]不同，我们的方法不要求系统配置成支持较大的内存页，所以能够很快的
应用到广泛的桌面和服务器系统。我们展示了该方法虽然是使用 JavaScript 实现的，但是依然可以在实际的时间长度里完成。

- 我们展示了一种 **功能完善的用无需特权的 JavaScript 发动 LLC 攻击** 的方法。我们用隐藏通道的方式，评估了它的性能，包括在同一个机器、不同进程之间
和在虚拟机与它的主机之间。基于 JavaScript 的通道与[23]中用机器语言实现的方法类似，都可以达到美秒几百kb的速度。

- 我们展示了怎么利用基于缓存的方法来有效地**跟踪用户行为**。缓存攻击的这一应用与我们的攻击模型更相关，与密码分析应用在其它成果中不同。

- 最后，我们**分析了可能的反制措施**针对攻击和它们全系统的代价。

**文档结构××：
第二章，攻击方法不同阶段的设计与实现。
第三章，基于攻击方法建立起来的隐藏通道，这个通道也被用来验证方法的性能。
第四章，缓存攻击如何被用来跟踪用户在浏览器内外的行为。
第五章，总结，提出反制措施和仍未解决的研究挑战。

## 2 攻击方法

正如前文所诉，一次成功的 填充+探测 攻击包含几个步骤：为一个或多个组建立移除集，填充组，触发受害者的操作，最后再次填充组。
虽然填充和探测实现起来很简单，但是要找到对应与某个系统操作的组并且为它建立移除集就不那么容易了。在本章里，我们描述了这几个步骤用 
JavaScript 如何实现。

### 2.1 建立一个移除集

### 2.1.1 设计

正如[23]写到，填充+探测 攻击的第一步是替被攻击的进程所共享的组建立一个移除集。这个移除集包含一系列的变量，这些变量被 CPU 映射到相同的
组里。参考文[20]的建议，使用链表是为了避免 CPU 的内存预读和流水线优化。我们显展示了怎么为任意一个组建立一个移除集，然后解决了如何
找到与受害者共享的内存块的问题。

文章[17]指出，一级缓存是依据虚拟地址的低位的比特来决定组的分配的。假设攻击者知道变量的虚拟地址，在一级缓存的攻击模型里建立移除集很容易。
另一方面，LLC里变量的组分配是依照物理内存的地址进行的，而且一半的非特权进程无法知道分配过程。文[23]的作者为了绕开这个问题，假设系统用
较大的页模型，在这个模型里，物理地址和虚拟地址的低21位是相同的，并且用迭代的算法来获得高位的组的索引。

在我们所考虑的攻击模型里，系统运行在4K的页模型下，物理地址和虚拟地址只有最低的12位是相同的。雪上加霜的是，JavaScript没有指针的概念，所以
自己定义的变量的虚拟地址也是不知道的。

从64位物理地址到13位的组索引的映射被Hund等人研究过。他们发现，访问物理内存里一段连续的、8MB大小的“eviction buffer”会让三级缓存里的所有组
都失效。虽然我们没有办法在用户态下分配这样的一个 evition buffer （实际上，文章[12]是通过内核模式的驱动达成的），我们用 JavaScript在
虚拟内存里分配了一个8MB大小的数组（实际是由系统分配的随机、不连续的4K物理内存页的集合），然后测量迭代这个缓存在系统范围内的影响。
我们发现在迭代访问了这个 eviction buffer 后如果立即访问内存中其它不相关的变量，访问的延迟会显著的增加。
另外一个发现是，即使不访问整个缓存而是每隔64字节去访问，这个现象依然存在。但是，我们所访问的131K个偏移值到8192个可能的组的映射关系
并没有立刻清晰起来，因为我们不知道我们的缓存里各个页在物理内存中的地址。


解决这个问题一个不成熟的做法是，给定一个任意的“受害者”在内存中的地址，通过暴力手段从131K个偏移中找到12个与这个地址共享组的地址。要完成这点，
我们可以从131K个偏移量固定几个作为子集，然后在迭代了所有的偏移量后测量下访问的延迟有没有变化。如果延迟增加了，意味着集合里包含着12个与
受害者地址共享组。如果延迟没有变化，那子集里不包括12个地址中的任何一个，这样受害者地址就还在缓存里。把这个过程重复8192遍，每次用一个不同的
受害者地址，我们就可以识别每个组并且建立自己的数据结构。

受这个启发立刻写出来的程序会运行时间会非常长。幸运的是， Intel MMU 的页帧大小（章节1.1）非常有帮助，因为虚拟地址是页对齐的，每个虚拟地址的
低12位和每个物理的低12位是一致的。据 Hund 等人所称，12个比特中的6个被用来唯一决定组索引。因此，eviction buffer 中的一个偏移会和其它8K偏移
共享12到6位，而不是所有131K个。而且，只要找到一个组就能立刻知道其它的63个在相同页帧里的组。再加上JavaScript分配大的数据缓存的时候是
和页帧的边界对其的，所以可以用算法1中的贪心算法。

**Algorithm 1** Profiling a cache set
Let S be the set of unmapped pages, and address x be an arbitrary page-aligned address in memory

1. Repeat k times:

```
(a) Iteratively access all members of S
(b) Measure t 1 , the time it takes to access x
(c) Select a random page s from S and remove it
(d) Iteratively access all members of S\s
(e) Measure t 2 , the time it takes to access x
(f) If removing page s caused the memory access to speed up considerably (i.e., t 1 − t 2 > thres),
then this page is part of the same set as x. Place it back into S.
(g) If removing page s did not cause memory access to speed up considerably,
then this address is not part of the same set as x.
```
2. If |S| = 12, return S. Otherwise report failure.

多次运行这个程序，我们可以逐渐的建立一个 eviction set 来覆盖大部分的缓存，除了那些被 JavaScript 本身运行所使用的。我们注意到，
与[23]中的算法建立的 eviction buffer 不同，我们的 eviction set 不是正统的 - 因为JavaScript 没有指针的概念，所以如果我们发现了一个
eviction set 我们没有办法知道它对应着 CPU 高速缓存的哪个组。此外，在相同的机器上每次运行这个算法都会得到不同的映射。这也许是源于4K的页大小
而不是2MB的页大小，即使不用JavaScript用机器码也无法改变。

### 2.1.2 验证

我们用 JavaScript 实现了 算法1 并且在安装了 Ivy Bridge， Sandy Bridge，Haswell系列 CPU 的机器上进行验证，机器上装有 Safari 和 Firefox
对应运行在 Mac OS Yosemite 和 Ubuntu 14.04 LTS 操作系统上。系统并没有被配置使用大的页而是用默认的 4K 页大小。列表1显示了实现 算法1.d
和 算法1.e 的代码，演示了JavaScript下怎么遍历链表和测量时间。算法的运行在 Chrome 和 Internet Explorer 下依赖的额外的几个步骤在章节5.1中。

```javascript
// Invalidate the cache set
var currentEntry = startAddress;
do {
    currentEntry = probeView.getUint32(currentEntry);
} while (currentEntry != startAddress);

// Measure access time
var startTime = window.performance.now();
currentEntry = primeView.getUint32(variableToAccess);

var endTime = window.performance.now();
```
算法1

![图2](../assets/figure2.png)

图2显示了 profiling algorithm 的性能，使用 Intel i7-3720QM， 装有 Firefox 35.0.1 和 Mac OS 10.10.2 。我们很高兴的发现在30秒内就
映射了超过25%的组，1分钟内就达到了50%。这个算法并行是非常简单的，因为大部分的执行时间花在了维护数据结构上，只有一小部分实际花在让缓存失效和
度量上。整个算法不到500行JavaScript代码。

![图3](../assets/figure3.png)

为了验证我们的算法能够辨别不同的组，我们设计yin了一个实验来比较一个变量被flush前后的访问延迟。图3显示了两种方式访问变量的概率分布函数。灰色的是
用我们的方式从缓存中flush出去的，黑色是贮存在缓存里的。时间的测量是用JavaScript的高精度计时器，因此也包括了JavaScript运行时的延迟。
两者的不同是显而易见的。图4显示的是在每个组有16个条目的较早版本的 Sandy Bridge CPU 上捕捉到的结果。我们把这种视觉呈现称作 “内存谱图”，
因为它看起来很像声音的谱图。

![图4](../assets/figure4.png)

![图5](../assets/figure5.png)

图5显示的是每隔400ms抓取一次的内存谱图。其中X轴对应时间，Y轴对应不同的组。例子中的时间分辨率是250微秒，检测了一共128块个组。每个点的密度
代表了这个组在这个时间的访问延迟。黑色代表延迟较低，意味从上次测量到现在没有其它进程访问过这个组。白色意味着攻击者的数据在上次测量之后被清除了。

细看这个内存谱图可以得到几个显而易见的事实。首先，很明显虽然没用机器语言指令而是用了 JavaScript 的计时器，测量的抖动很小，活跃和不活跃的组
很容易被区分。很容易注意到图中有几条垂直的线，意味着同一时间间隔里有多个相邻的组被访问。因为连续的组对应的物理内存的地址也是连续的，我们
相信这个信号代表着一个超过 64 字节的汇编指令。还有一些聚在一起的组被同时访问。我们推理这代表着变量的访问。最后，横着的白线预示着一个变量
被不断地访问。这个变量可能是属于测量代码的或是当前的 JavaScript 运行时。从一个没有任何特权的网页能得到这么多信息真是太了不起了。

### 2.2 在缓存里找有意思的区域

清除集让黑客能够监控任意一个缓存里的组的动作。因为我们得到的清除集是不典型的，因此攻击者必须想办法把测量的组和受害者的数据或是代码的地址
关联起来。这个学习/分类的问题已经由 Zhang 和 Yarom 分别在 文[25] 和 文[23] 里提出了，他们采用了不同的例如 SVM 的机器学习的算法试图从
缓存延迟的测量数据里找到规律。

为了有效地展开这个学习的过程，攻击需要诱导受害者做一些操作，然后检查哪些组被这个操作访问到，详见 算法2。

```
Let S i be the data structure matched to eviction set i
1. For each set i:
    (a) Iteratively access all members of S i to prime the cache set
    (b) Measure the time it takes to iteratively access all members of S i
    (c) Perform an interesting operation
    (d) Measure once more the time it takes to iteratively access all members of S i
    (e) If performing the interesting operation caused the access time to slow down considerably, then the operation was 
    associated with cache set i.
```

因为JavaScript受到一系列的权限限制，实现步骤(c)是很有挑战的。与之形成对比的是 Apecechea等人能够用一个空的**sysenter**调用来触发一次
细小的内核操作。为了实现这个步骤，我们必须调查 JavaScript 的运行时来发现哪些函数会触发有意思的行为，例如文件访问，网络访问，内存分配等等。
我们还对那些运行时间相对较短，不会产生遗留的函数感兴趣。遗留可能导致垃圾回收，进而影响步骤(d)的测量。Ho 等人在 文[10] 中已经找到了这样的
几个函数。另外一种方式是诱导用户代替攻击者执行一个特定的操作（比如在键盘上按一个键）。这个例子里的学习过程可能是结构化的（攻击者知道受害者
将要执行的时机），也可能是非结构化的（攻击者只能假设系统一段时间内的响应缓慢是由受害者的操作导致的）。这两种方法都被使用，详见章节4。

因为我们的代码会一直检测到JavaScript运行时的活动，高性能的计时器的代码和浏览器其它模块的代码，实际上我们调用两个相似的函数并检查它们
两次活动剖析的**对比**，以此来寻找相关的组。

## 3 JavaScript实现的基于高速缓存的隐藏信道

### 3.1 动机

正如 文23 展示的，LLC 访问的方式可被用来建立一个高带宽的隐藏信道并用来在同一台宿主上的两个虚拟机之间渗透敏感的信息。在我们的攻击模型里，
攻击者不在同一台宿主上的虚拟机里而是在一个网页里，隐藏信道的动机虽然不一样但是也很有趣。

经由我们的动机，假设一家安全机构在追踪犯罪大师Bob。通过钓鱼项目，机构在 Bob 的个人电脑上装了一个被称作 Advanced Persistent Threat 的
软件。APT被设计用来记录 Bob 的犯罪记录并发送到机构的秘密服务器上。然而 Bob 非常的警觉，他使用了启用了强制 Information Flow Tracking
的操作系统。操作系统的这个功能阻止了 APT 在访问了可能含有隐私用户数据的文件后连上网络。

这个机构可以立刻采用基于 JavaScript 的高速缓存攻击，只要 Bob 能被诱导访问一个由机构的控制的网页。APT可以利用高速缓存的边信道和恶意网站
通信，这样不会通过网络传输用户的隐私数据，而且不会触发操作系统的 flow tracking 功能。

这个案例受到了 “RF retro-reflector” ，这个设计归属于一家安全机构，在这个设计里一台像是麦克风的收集器并不会把接收到的信号直接发送出去，
而是转换到由一个外部”收集设备“发送给它的“照射信号”上去。
 
### 3.1.1 设计

我们隐藏信道的设计受到两个需求的影响：第一，保持发送端的简单，尤其是我们不想让它执行 章节2.1 中的清楚集算法。第二，因为接收端的移除集是非
正规的，它应该足够简单，这样接受者就可以搜索到发送端转换信号到了哪一个组。

为了满足这些需求，我们的发射器/ APT 在自己的内存中分配了4K的数组，并且不断地把收集到的数据转换成这个数组被访问内存的模式。这个4K的数组
覆盖了64个组，这样APT在每个时间周期里就能传送64比特的数据。为了能保证内存的访问能够被接收端定位到，相同的访问模式被重复运用到数组的几个
拷贝上。 因此缓存中很可观的一部分都会被执行到，文[23] 中的方法使用的是正规的移除集，因此只会激活两条线。

接收端的代码会为操作系统的内存做一个剖面，然后搜索含有被APT转换过的数据的 page frame。这个数据会被从内存访问的模式里解码出来然后传回数据库，
始终都不会违背操作系统对flow tracking 的保护。

### 3.1.2 验证

我们的攻击模型假设发送端使用（相对较快的）机器语言邪恶，而接收端是用JavaScript写的。因此，我们假设系统的限制性因素是恶意网站的
采样速度。

为了验证隐藏信道的带宽，我们写了一个小程序用预先设定好的模式来遍历系统的内存（例子会用到含有单词"Usenix"的比特图）。
然后，我们试图用JavaScript高速缓存攻击来寻找这一访问模式，之后测量JavaScript代码所能达到的最大的频率。

![图6](../assets/figure6.png)

图6 显示的内存谱图捕捉到了这一隐藏信道。隐藏信道名义上的带宽通过测量大约是320kbps，而文[23]中用机器码得到的跨虚拟机隐藏信道
的带块大概是1.2Mbps，足以相提并论。

![图7](../assets/figure7.png)

图7 中相似的内存谱图并非由运行在主机上的接收端代码得到的，而是在一台虚拟机上得到的（Firefox 34浏览器，Ubuntu 14.01 系统，
VMWare Fusion 7.1.0 宿主）。尽管在这个场景下高峰频率只能到大约 8kbps，但是虚拟机中的网页能够探测到底层硬件，这着实让人惊讶。

## 4 利用高速缓存攻击跟踪用户行为

绝大多数关于高速缓存攻击的研究都假设攻击者和受害者位于同一家云供应商的数据中心。这样的机器一般不会配置成接收交互式的输入，
所以该领域的大部分研究都聚焦于如何获得加密钥匙或其它保密的状态元素，譬如随机数生成器的状态[26]。 本文将研究怎么利用高速缓存
攻击来跟踪用户的行为。我们注意到[20]已经尝试基于一级缓存对系统负载进行细粒度的度量，以此跟踪按键时间的事件。

本案例研究了恶意网站怎么用高速缓存跟踪用户的活动。在接下来即将展示的的攻击里，我们假设用户在一个背景标签页或窗口里加载
了一个恶意网页，并且在另一个标签或是另外一个完全没有互联网连接的应用里执行了敏感的操作。

我们选择了把焦点集中在鼠标操作和网络活动上，因为处理它们的系统代码没法忽略不计。因此，我们推测这些操作会有相对较大的缓存脚印。
正如下文所述，它们也很容易被JavaScript受限的安全模型所触发。

### 4.1 设计

两种攻击的结构是类似的。首先，是剖析过程，攻击者可用JavaScript探测某一个组。接着，在训练阶段，待检测的活动被触发，伴随着
对高速缓存区的高精度采样。一边是用测量脚本直接触发网络活动（通过执行一个网络请求），一边是在训练阶段不停的摇晃鼠标。

通过比较高速缓存在训练阶段闲时和忙时的活动，攻击者了解到相关的活动会唯一激活那部分的组，并且训练出一个组的分类器。最后，
在分类阶段，攻击者不断地监控相关组。

我们用一个基本的非结构化的训练过程，假设训练过程中系统进行的最集中的操作就是被测量的。为了利用这点，我们计算了随着时间的
每次测量的 Hamming 权重（等于在某个周期内活跃组的个数），之后应用 k-meas 算法把测量数据做聚类。
然后计算每个簇中每个组的访问延迟，最终得到每个簇的中心。遇到未知的测量矢量，我们会计算这个矢量和各个中心的 Euclidean 距离，
并把它归到最近的那一类。

在分类阶段，我们用命令行工具 wget 生成网络流量，并且将鼠标移动到窗口以外。为了获得网络活动的真实数据，我们同时用 tcp-dump 
来测量系统的流量，然后用`tcp-dump`记录的时间戳映射到分类器所检测到时间。为了获得鼠标操作的真实数据，我们写了一个页面记录所有
鼠标事件的时间戳。需要强调的是记录鼠标活动的页面不在测量代码的浏览器（Firefox），而是运行在另一个浏览器里（Chrome）。

### 4.2 验证

![图8](../assets/figure8.png)
![图9](../assets/figure9.png)

活动测量的结果在 图8 和 图9 中显示了。两个图片的顶端显示了高速缓存子集的事实活动。图片的底端是分类器的输出结果，一起显示的
还有外部收集的真实数据。正如图片展示的那样，我们及其简单的分类器在识别鼠标操作和网络活动方面非常有效。毫无疑问，使用更加
高级的训练和分类技巧可以进一步提高攻击的效果。需要强调的是，鼠标操作的检测器并不会检测网络活动，反之亦然。

分类器的测量频率只有500Hz。结果就是，它没有办法统计单个的包而是在一个阶段里活跃还是不活跃。另一方面，检测鼠标活动的代码比
基本数据采集到的事件更多。这是因为Chrome 浏览器对鼠标事件的频率限制到了大约60Hz。

监测网络活动可以作为深度挖掘用户行为的基础，正如 Chen 等人在一篇著名的文章[5]中描述的。虽然 Chen 等人假设网络层的攻击者可以
监控受害者所有流入和流出的数据，但是这里所展示的技术本质上可以让恶意网站监控用户同时进行的网络操作。这个攻击可以被更多的指标
增强，例如内存分配（见文[13]），DOM布局事件，磁盘读写等。

## 5 讨论

本文显示了边信道攻击比预期的攻击范围大很多。本文提出的攻击可针对互联网上的大部分机器而不局限于某些特定的攻击场景。有如此多的系统突然间易受
边信道攻击意味着防止边信道攻击的算法和系统应当广泛使用而不是在特定环境下。

### 5.1 易受攻击系统的普遍性

我们的攻击涉及到一台运行在 Sandy Bridge， Ivy Bridge, Haswell 或者 Broadwell CPU上的微结构个人计算机。据 IDC 的数据显示，2011年以后
的计算机80%都满足这一条件。进一步的没假设用户使用的浏览器支持 HTML5 高精度计时器和类型数组的规范。表1 列举了各个浏览器厂商支持这几个 API
的最早的版本，和易被攻击的版本占全球互联网流量的比重，统计数据来自 StatCounter GlobalStatas 2015年一月份的结果。如表所示，今天80%的浏览器
都无法抵御此类攻击。

Browser brand| High Resolution Time Support | Typed Arrays Support | Worldwide prevalence
-------------|-------------|-------------|-------------
Internet Explorer | 10  | 11  | 11.77%
Safari            | 8   | 6   | 1.86%
Chrome            | 20  | 7   | 50%
Firefox           | 15  | 4   | 17.67%
Opera             | 15  | 12.1| 1.2%
Total             | -   | -   | 83.03%

攻击能否取得效果，取决于能不能用 JavaScript 高精度的时间 API进行精准的测量。W3C 虽然建议 API 的最高精度的时间戳是“毫秒的千分之一”，但是
并没有建议该值的最大精度，实际上浏览器不同、操作系统不同这个值也会经常变。举个例子，我们在测试过程中发现 MacOS 上的 Safari 浏览器可以精确
到纳秒，而 Windows 上的 IE 浏览器只能精确到 0.8 微秒。 另一方面， Chrome 浏览器在所有我们测试的操作系统上都表现为一致的 1 微秒。

所以 图3 中，单次缓存命中和缓存未命中的差别大概是 50 纳秒，采样和测量的脚本在遇到力度更细的系统时要稍加改动。在采样阶段，我们重复读取内存
来放大时间差而不是测量单次。在测量阶段，我们没有办法放大每次缓存的未命中，但是我们可以利用来自相同page frame的代码通常会让相邻的组失效这一点。
只要64 个组里 有 20 个注册可缓存未命中，我们的攻击就可以在哪怕是毫秒级的进度上进行。

我们提出的这种攻击还可以很容易的运用到手机、平板这类移动设备上。需要注意的是安卓浏览器从 4.4 版本开始支持高精度的时间API和类型数组，但在
本文撰写的时候 iOS Safari （8.1） 还不支持高精度的时间 API。

### 5.2 反制措施

本文描述的攻击之所以可行是因为是个设计和实现在微架构的开始和，并最终在 JavaScript 运行时： 映射内存到一个缓存，JavaScript 高速内存访问
和高进度的计时器。每一步都可以采取一些缓解措施，但是着会对系统的正常使用产生影响。

在微结构这层，修改物理内存到缓存线的映射方式会阻止我们的攻击，即不再使用底12位比特中的6个。类似的，换用不包含的缓存微结构而不是用包含式的。
可以让我们的代码无法从一级缓存中清除数据，使得测量更加困难。不过这两个设计当初被选择是为了让CPU的设计和缓存使用更高效，改变它们会让很多的
应用性能受到影响。此外，修改CPU 微结构可不是一件小事，升级已经部署的硬件一定是不肯能的。

在 JavaScript 这层，似乎降低高精度计时器的分辨率可以让攻击更难发动。然而，高精度计时器的建立是为了解决 JavaScript 开发者的实际问题的，
从音乐到游戏再到增强现实和远程医疗。

一种可能的权宜之计是限制只有获得用户许可的应用才可以访问计时器（例如，通过显示一个确认窗口）或者通过第三方的许可（例如下载自可信的
 “app store”）
 
一种有意思的方式是使用启发式采样来检测和阻止此类攻击。正如 Wang 等人所述，大量的算法和二进制的指令可以揭示密码学应用的元素 [21] ，可以
注意到，攻击里访问内存的测量步骤会有一定的模式。因为现代的 JavaScript 运行环境已经详细检查了运行时的性能，profile-guided 优化手段，
英爱也可以通过检测 profiling-like 的操作来执行和修改返回结果（例如，在高精度计时器里加上抖动，或者动态的调整数组在内存中的位置等）


### 5.3 结论

在这篇论文里，我们演示了在微处理器架构上如何发动边信道攻击，此类攻击已被认为是非常有效的，并且可以被不可信的网页有效地发动。
与缓存攻击一般被用于密码分析应用不同，本文介绍了这种方式如何被有效地利用来跟踪用户的行为。边信道攻击的范围已经被拓展了，
这意味着必须设计新一类的安全系统应对边信道攻击。

## 致谢 

我们很感谢激 Henry Wong 对于 Ivy Bridge 缓存替换策略的研究和 Burton Rosenberg 对于页和页框的指导。

## 参考文献

见原文

